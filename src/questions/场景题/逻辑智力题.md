## 1. pdd

- 64匹马，8个赛道，只知道每次比赛的排名顺序，不知道具体的时间。需要几次比赛，可以确定跑得最快的前四匹马？
> 充分必要的次数是11场比赛。理由如下：  
> count_all = 0  
> 首先每八匹马一组进行比赛，总共分成了8组(A,B,C,D,E,F,G,H)，需要进行8场比赛，则  
> count_all += 8  
> 这样可以确定每组的比赛名次（A1>A2>A3...A8>B1>B2...）。将每组的第一名（A1,B1,C1,D1...）进行一场比赛  
> count_all += 1  
> 可以确定每组第一名的顺序：(假如：A1>B1>C1>D1>E1>...) ，因为要找到前四匹马，所以直接排除 E,F,G,H组，
> 并且D组只有D1可能在前四名，C组只需要考虑C1和C2（因为A1，B1一定在前面），A1一定是最快的，这里需要筛选一下：  
> ~~A1~~ B1 C1 D1  
> A2 B2 C2   
> A3 B3    
> A4     
> 可知还需要对这九匹马再进行比赛，九匹马八个赛道可知最多需要比赛两场:  
> count_all += 2
> 综上，总共需要11场比赛，就可以筛选出前四匹最快的马

- 有八个球，有一个偏重，用天平最多几次可以找出这个小球？
> 只需要2次就可以找出偏重的小球。理由如下：
> 反向思维：称一次最多可以从多少个小球中找到偏重的小球？
> 答案是3个，比如A，B，C三个小球，有一个偏重。用天平选2个小球（A，B）比较，
> 如果不平衡，那么倾向哪边哪边的小球就是偏重的那个；
> 如果平衡，那么另外一个小球C就是偏重的那个。
> 再套一层，把三个小球打包到一个组，那么称两次最多可以从(3 * (1 + 1 + 1) = $ 3^2 $ )9个小球中找出偏重的小球，  
> 又因为 8 < 9 ，所以最多称2次就可以找出，正向思维： 
> 把8个球分成： 3， 3， 2，然后先称3， 3，如果平衡，就在另外2个小球中，还需要一次。
> 如果不平衡，就在倾向的3个小球中，还需要一次也可以找出。  

- 有10万个长度>=3的字符串，比如：ABC, CDD, DFA...，现在将这些字符串的收尾依据相同的字符连接在一起，
- 判断是否可以连接成一个且只有一个环？
> 思路：(不确定是否正确)  
> 首先将所有的字符串依据首和尾的关系建立映射(比如A->C,C->D,D->A...这样)，储存在HashMap中，  
> HashMap的value需要再嵌入一个SortedMap，根据字母顺序排序，它的value统计次数  
> {key: A, value: {key: C, value: count}} // 这里需要统计一下次数  
> 然后随机选择一个map作为开始，比如：A，读取其value选择第一个sorted map（比如C），并将其count-1，  
> 如果count到0了，需要remove掉这个，sorted map，如果sorted map空了，整个map remove掉。   
> 再根据C去寻找下一个映射，如果没找到，说明不可能构成环，直接return False  
> 否则不断重复上述步骤，并且在这个过程中需要构建一个Set集合，记录连接的节点元素（比如C，...）
> 直到又回到A。  
> 接下来需要判断是否Map中还有元素，如果没有，就肯定可以构成环，返回 True；  
> 否则，又选择一个map来重复上述过程...  
> 这样我们就最终得到了多个set。这个是有用的，因为可能存在两种情况：  
> 情况1. ABC CDE EEA | EFB BCE，  
> 情况2. ABC CDA | DCB BCD，
> 情况1可以将多个环合并成一个环；情况2则不行，这里就需要借助我们刚刚保存的set了，
> 只要这些set有重叠的，就可以合并，返回True，否则就返回False
> 



